# -*- coding: utf-8 -*-
"""face_detectors.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MXBtG-2HW6sJq6RnEgkYI-QUbPxxigUD
"""

import cv2
import numpy as np
import dlib
import os
from google.colab.patches import cv2_imshow


modelFile = "/res10_300x300_ssd_iter_140000 (1).caffemodel"
configFile = "/deploy (1).prototxt"

# Load pre-trained model and configuration files
net = cv2.dnn.readNetFromCaffe(configFile, modelFile)

# Load the pre-trained Haar Cascade classifiers for face detection
frontal_face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
profile_face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_profileface.xml')

# Define a public variable count
count = 0

def dnn_face_highlighter(image_path):
    global count
    img = cv2.imread(image_path)

    if img is None:
        print(f"Error: Could not read image at {image_path}")
        return None

    (h, w) = img.shape[:2]
    blob = cv2.dnn.blobFromImage(cv2.resize(img, (300, 300)), 1.0,
                                 (300, 300), (104.0, 177.0, 123.0))

    net.setInput(blob)
    detections = net.forward()

    # If no faces are detected, return the original image
    if detections.shape[2] == 0:
        count += 1
        return img

    # Create a mask of zeros (black image) of the same size as the original image
    mask = np.zeros_like(img)

    for i in range(0, detections.shape[2]):
        confidence = detections[0, 0, i, 2]
        if confidence > 0.5:
            box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
            (startX, startY, endX, endY) = box.astype("int")
            # Create a white rectangle on the mask where the face is detected
            mask[startY:endY, startX:endX] = img[startY:endY, startX:endX]

    # Apply the mask to the original image
    result = cv2.bitwise_and(img, mask)

    return result

def cascade_highlighter(image_path):
    global count

    img = cv2.imread(image_path)

    if img is None:
        print(f"Error: Could not read image at {image_path}")
        return None


    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Detect faces in the image
    frontal_faces = frontal_face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))
    profile_faces = profile_face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

    # Combine both face detections
    faces = list(frontal_faces) + list(profile_faces)

    # If no faces are detected, return the original image
    if len(faces) == 0:
        count += 1
        return img

    # Create a mask of zeros (black image) of the same size as the original image
    mask = np.zeros_like(gray, dtype=np.uint8)

    # Iterate through the detected faces and create a mask over the face area
    for (x, y, w, h) in faces:
        cv2.rectangle(mask, (x, y), (x+w, y+h), (255), -1)

    # Create a new image with only the face area from the original image
    result = cv2.bitwise_and(img, img, mask=mask)

    return result

def dlib_highlighter(image_path):
    global count
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Initialize dlib's face detector
    detector = dlib.get_frontal_face_detector()

    # Detect faces
    faces = detector(gray)

    # If no faces are detected, return the original image and count as 0
    if len(faces) == 0:
        count += 1
        return image

    # Create a mask with the same dimensions as the image
    mask = np.zeros_like(image)

    # Fill the mask with white color inside the face bounding boxes
    for face in faces:
        x, y, w, h = (face.left(), face.top(), face.width(), face.height())
        mask[y:y+h, x:x+w] = image[y:y+h, x:x+w]

    # Apply the mask to the original image
    masked_image = cv2.bitwise_and(image, mask)

    return masked_image

def process_images_in_folder(folder_path):
    global count
    count = 0
    total_images = 0
    for filename in os.listdir(folder_path):
        if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
            total_images += 1
            image_path = os.path.join(folder_path, filename)
            image = dnn_face_highlighter(image_path)
            cv2_imshow(image)
    return count, total_images


folder_path = '/content/drive/MyDrive/vision project/data'  # Replace with the actual folder path
count, total_images = process_images_in_folder(folder_path)
if total_images > 0:
    print(f"Proportion of images with no detectable faces: {count / total_images:.2f}")
else:
    print("No images found in the specified folder.")



